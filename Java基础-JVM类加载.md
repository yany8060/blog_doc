
> **JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化**

### 类加载过程
#### 加载

1. 通过一个类的全限定名来获取其定义的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。


> JVM中的ClassLoader类加载器加载Class发生在此阶段
> 
> 这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也**可以在运行时计算生成（动态代理）**，也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。


#### 验证
验证的目的是为了**确保Class文件中的字节流包含的信息符合当前虚拟机的要求**，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：**文件格式的验证、元数据的验证、字节码验证和符号引用验证**。

* 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
* 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
* 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
* 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。


#### 准备
准备阶段是正式为**类变量（static变量）**分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。

1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
2. 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

假设一个类变量的定义为：

```java
public static int value = 3；
```
那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器\<clinit\>（）方法之中的，**所以把value赋值为3的动作将在初始化阶段才会执行。**

static final常量在编译期就将其结果放入了调用它的类的常量池中

#### 解析
#### 初始化
#### 类加载器

* 启动类加载器（Bootstrap ClassLoader）
* 扩展类加载器（Extension ClassLoader）
* 应用程序类加载器（Application ClassLoader）
* 自定义类加载器

#### 双亲委派模型

**工作流程：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

